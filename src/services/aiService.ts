import axios from "axios";
import { ipcMain } from "electron";
import * as fs from "fs";
import * as path from "path";
import { getAIConfig } from "./configService";

/**
 * Handles requests for AI content generation
 */
export function setupAIService() {
  // Registers the IPC handler for AI content generation
  ipcMain.handle("generate-ai-content", async (_, prompt, context) => {
    return await generateContent(prompt, context);
  });
}

/**
 * Generates AI content based on the prompt and context
 */
async function generateContent(
  prompt: string,
  context: any
): Promise<{ content: string }> {
  try {
    // Validates the request
    if (!prompt || prompt.trim() === "") {
      throw new Error("Please provide a prompt for the AI.");
    }

    // Gets current AI config
    const aiConfig = getAIConfig();

    // Constructs the system prompt with context
    const systemPrompt = constructSystemPrompt(context);

    if (aiConfig.provider === "openai") {
      return await generateOpenAIContent(prompt, systemPrompt, aiConfig);
    } else {
      return await generateAnthropicContent(prompt, systemPrompt, aiConfig);
    }
  } catch (error) {
    console.error("AI content generation error:", error);

    // Type guard for axios errors
    if (error && typeof error === "object" && "response" in error) {
      // API response error
      const axiosError = error as {
        response: {
          status: number;
          data: { error?: { message?: string } };
        };
      };
      throw new Error(
        `AI service error: ${axiosError.response.status} - ${
          axiosError.response.data.error?.message || "Unknown error"
        }`
      );
    } else if (error && typeof error === "object" && "request" in error) {
      // Network error
      throw new Error(
        "Network error connecting to AI service. Please check your internet connection."
      );
    } else {
      // Other errors
      throw error instanceof Error ? error : new Error(String(error));
    }
  }
}

/**
 * Generates content using OpenAI API
 */
async function generateOpenAIContent(
  prompt: string,
  systemPrompt: string,
  aiConfig: any
): Promise<{ content: string }> {
  if (!aiConfig.openaiApiKey) {
    throw new Error(
      "OpenAI API key not configured. Please update your settings."
    );
  }

  const model = aiConfig.openaiModel || "gpt-4o-mini";

  const response = await axios.post(
    "https://api.openai.com/v1/chat/completions",
    {
      model: model,
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: prompt },
      ],
      max_tokens: 2048,
      temperature: 0.7,
    },
    {
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${aiConfig.openaiApiKey}`,
      },
    }
  );

  if (
    response.data &&
    response.data.choices &&
    response.data.choices.length > 0
  ) {
    return {
      content: response.data.choices[0].message.content,
    };
  } else {
    throw new Error("No content generated by OpenAI.");
  }
}

/**
 * Generates content using Anthropic Claude API
 */
async function generateAnthropicContent(
  prompt: string,
  systemPrompt: string,
  aiConfig: any
): Promise<{ content: string }> {
  if (!aiConfig.anthropicApiKey) {
    throw new Error(
      "Anthropic API key not configured. Please update your settings."
    );
  }

  const model = aiConfig.anthropicModel || "claude-3-5-sonnet";

  const response = await axios.post(
    "https://api.anthropic.com/v1/messages",
    {
      model: model,
      system: systemPrompt,
      messages: [{ role: "user", content: prompt }],
      max_tokens: 2048,
    },
    {
      headers: {
        "Content-Type": "application/json",
        "x-api-key": aiConfig.anthropicApiKey,
        "anthropic-version": "2023-06-01",
      },
    }
  );

  if (
    response.data &&
    response.data.content &&
    response.data.content.length > 0
  ) {
    return {
      content: response.data.content[0].text,
    };
  } else {
    throw new Error("No content generated by Claude.");
  }
}

/**
 * Constructs the system prompt with context information
 */
function constructSystemPrompt(context: any): string {
  let systemPrompt = `You are an AI writing assistant for both fiction and non-fiction authors. 
Your goal is to help the author create compelling narratives, characters, and settings.
Be creative, thoughtful, and provide high-quality writing assistance.

`;

  // Adds current chapter context if available
  if (context.currentChapter) {
    systemPrompt += `
The author is currently working on the following content:
---
${context.currentChapter}
---

`;
  }

  // Adds general character information if available
  if (context.characters && context.characters.length > 0) {
    systemPrompt += `
The story includes the following characters:
`;

    context.characters.forEach((character: any) => {
      systemPrompt += `- ${character.name}: ${character.description}\n`;
    });

    systemPrompt += "\n";
  }

  // Adds detailed information for referenced characters (using @ notation)
  if (context.referencedCharacters && context.referencedCharacters.length > 0) {
    systemPrompt += `
Referenced characters with detailed information:
`;

    context.referencedCharacters.forEach((character: any) => {
      systemPrompt += `
### ${character.name}
Description: ${character.description || "No description available"}
${
  character.traits && character.traits.length > 0
    ? `Traits: ${character.traits.join(", ")}`
    : ""
}
${character.goals ? `Goals: ${character.goals}` : ""}
${character.backstory ? `Backstory: ${character.backstory}` : ""}
`;

      // Add relationships if available
      if (character.relationships && character.relationships.length > 0) {
        systemPrompt += `\nRelationships:\n`;
        character.relationships.forEach((rel: any) => {
          const relatedChar = context.characters.find(
            (c: any) => c.id === rel.characterId
          );
          if (relatedChar) {
            systemPrompt += `- ${relatedChar.name}: ${rel.type} - ${rel.description}\n`;
          }
        });
      }

      systemPrompt += "\n";
    });
  }

  // Adds general location information if available
  if (context.locations && context.locations.length > 0) {
    systemPrompt += `
The story includes the following locations:
`;

    context.locations.forEach((location: any) => {
      systemPrompt += `- ${location.name}: ${location.description}\n`;
    });

    systemPrompt += "\n";
  }

  // Adds detailed information for referenced locations (using @ notation)
  if (context.referencedLocations && context.referencedLocations.length > 0) {
    systemPrompt += `
Referenced locations with detailed information:
`;

    context.referencedLocations.forEach((location: any) => {
      systemPrompt += `
### ${location.name}
Description: ${location.description || "No description available"}
${location.locationType ? `Type: ${location.locationType}` : ""}
${location.geography ? `Geography: ${location.geography}` : ""}
${location.climate ? `Climate: ${location.climate}` : ""}
${location.culture ? `Culture: ${location.culture}` : ""}
${location.notes ? `Notes: ${location.notes}` : ""}
`;

      // Add connections if available
      if (location.connections && location.connections.length > 0) {
        systemPrompt += `\nConnections to other locations:\n`;
        location.connections.forEach((conn: any) => {
          const connectedLoc = context.locations.find(
            (l: any) => l.id === conn.locationId
          );
          if (connectedLoc) {
            systemPrompt += `- ${connectedLoc.name}: ${conn.description}\n`;
          }
        });
      }

      systemPrompt += "\n";
    });
  }

  // Add referenced chapter content
  if (context.referencedChapters && context.referencedChapters.length > 0) {
    systemPrompt += `
Referenced chapters:
`;

    context.referencedChapters.forEach((chapter: any) => {
      systemPrompt += `
### Chapter ${chapter.index + 1}: ${chapter.title}
---
${chapter.content}
---

`;
    });
  }

  systemPrompt += `
Provide tailored, specific content that matches the tone, style, and context of the current chapter. 
Avoid generic suggestions. Format your response in Markdown when appropriate.
`;

  return systemPrompt;
}

/**
 * Logs AI usage for tracking purposes
 */
function logAIUsage(prompt: string, result: string): void {
  try {
    const logDir = path.join(
      process.env.APPDATA ||
        (process.platform === "darwin"
          ? path.join(process.env.HOME || "", "Library", "Application Support")
          : path.join(process.env.HOME || "", ".config")),
      "author-app",
      "logs"
    );

    // Ensures the log directory exists
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }

    const timestamp = new Date().toISOString();
    const logFile = path.join(
      logDir,
      `ai-usage-${new Date().toISOString().split("T")[0]}.log`
    );

    const logEntry = `[${timestamp}]\nPrompt: ${prompt}\n\nResult: ${result}\n\n---\n\n`;

    fs.appendFileSync(logFile, logEntry);
  } catch (error) {
    console.error("Failed to log AI usage:", error);
  }
}
